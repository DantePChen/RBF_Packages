from typing import Any, Container, Dict, Generic, Iterable, Iterator, List, Optional, Set, Tuple, TypeVar, Union
import maya.app.renderSetup.model.rendererCallbacks as rendererCallbacks
import maya.app.renderSetup.model.renderSetup as renderSetupModel
import maya.app.renderSetup.model.jsonTranslatorUtils as jsonTranslatorUtils
import maya.app.renderSetup.views.utils as utils
import maya.api.OpenMaya as OpenMaya
import maya.app.renderSetup.common.guard as guard
import maya.app.renderSetup.model.renderLayer as renderLayerModel
import maya.app.renderSetup.model.override as overrideModel
import maya.app.renderSetup.model.jsonTranslatorGlobals as jsonTranslatorGlobals
import maya.app.renderSetup.model.renderSetupPrivate as renderSetupPrivate
import json
import maya
import maya.mel as mel
from . import renderSetupRoles
import maya.app.renderSetup.model.undo as undo
import maya.cmds as cmds
import maya.app.renderSetup.model.overrideUtils as overrideUtils
import maya.app.renderSetup.model.renderSetupPreferences as userPrefs
from . import proxyFactory
import maya.app.renderSetup.model.plug as plug
import maya.app.renderSetup.model.nodeList as nodeList
import maya.app.renderSetup.model.collection as collectionModel
import maya.app.renderSetup.views.pySide.standardItem as standardItem
import weakref
import os


"""
This file contains all the classes which implement the Qt Model needed to benefit from the
Model/View design from Qt.

The design intent is that these classes only be used to implement Qt views.
They should be used as proxies to the underlying render setup data model
objects only by Qt views code, and in such cases only with as little code
as is required to interface with Qt.

All other uses, by any other code, should use the render setup data
model interface directly.  It already provides an encapsulation of the
underlying Maya objects, as well as observation and notification
capability.  There is no need to duplicate render setup data model
interfaces and services in Qt model interfaces and services: this
is a maintenance burden, introduces the possibility of error, and
requires additional testing, for no gain.  Similarly, Qt model code
should not perform any render setup data model computation or abstraction;
such services must be implemented in the render setup data model layer.
"""


from PySide2.QtCore import *


from PySide2.QtGui import QGuiApplication
from PySide2.QtGui import QStandardItemModel
from PySide2.QtGui import QColor
from functools import partial
from PySide2.QtGui import QFont
from PySide2.QtGui import QStandardItem
from PySide2.QtGui import QFontMetrics
from PySide2.QtWidgets import QApplication


if False:
    from typing import Dict, List, Tuple, Union, Optional

class UniqueOverrideProxy(object):
    def isUniqueOverride(self): ...
    def targetNodeName(self): ...
    __dict__ : dictproxy
    
    __weakref__ : getset_descriptor


class Template(object):
    """
    Base class for all the proxy classes to offer the template file import
    """
    
    
    
    def acceptableDictionaries(self, templateDirectory):
        """
        Find the list of template files applicable to a specific proxy
        """
        ...
    def findAllTemplateFiles(self, templateDirectory):
        """
        Find the list of all template files
        """
        ...
    def templateActions(self, templateDirectory):
        """
        Build the list of all possible template actions
        """
        ...
    __dict__ : dictproxy
    
    __weakref__ : getset_descriptor


class LabelColor(object):
    """
    Base class for all the proxy classes to offer the label color option
    """
    
    
    
    def getLabelColor(self): ...
    def setLabelColor(self, label): ...
    __dict__ : dictproxy
    
    __weakref__ : getset_descriptor


class DataModelListObserver(object):
    """
    Mixin class for proxy items so they can observe their underlying
    data model list.
    """
    
    
    
    def __init__(self, *args, **kwargs):
        """
        # As per
        # 
        # https://rhettinger.wordpress.com/2011/05/26/super-considered-super/
        #
        # the signature of __init__() callee methods needs to match the caller.
        # We therefore use the most generic parameter list to accomodate the
        # needs of any other base class in the list of base classes.
        """
        ...
    def addActiveLayerObserver(self): ...
    def addListObserver(self, model): ...
    def ignoreListItemAdded(self): ...
    def listItemAdded(self, listItem):
        """
        React to list item addition to the data model.
        
        If a list item is added to the data model, we create a
        list item proxy and insert it at the proper position.
        """
        ...
    def listItemRemoved(self, listItem):
        """
        React to list item removal from the data model.
        
        If a list item is removed from the data model, we remove the row
        corresponding to its list item proxy.
        """
        ...
    def removeActiveLayerObserver(self): ...
    def removeListObserver(self, model): ...
    __dict__ : dictproxy
    
    __weakref__ : getset_descriptor


class RenderSetupProxy(DataModelListObserver, Template, QStandardItemModel):
    """
    # Because of MAYA-60799, QStandardItemModel must appear last in the list of
    # base classes.
    """
    
    
    
    def __eq__(self, other: Any) -> bool: ...
    def __init__(self, parent='None'): ...
    def __ne__(self, other: Any) -> bool: ...
    def aboutToDelete(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def acceptImport(self): ...
    def attachChild(self, renderLayer, pos): ...
    def child(self, row, column='0'): ...
    def copyForClipboard(self, proxies):
        """
        Export the selected proxies to a JSON string, for clipboard use.
        
        Render setup data model classes may implement copyForClipboard
        in a special way.  For example, render layers are unconditionally
        set to be not visible, which avoids two problems:
        - It avoids a potentially costly render layer switch operation on paste.
        - Pasting a layer shouldn't change the currently-visible layer.
        """
        ...
    def createListItemProxy(self, renderLayer): ...
    def createRenderLayer(self, renderLayerName): ...
    def dispose(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def dropMimeData(self, mimeData, action, row, column, parentIndex): ...
    def exportSelectedToFile(self, filePath, notes, proxies):
        """
        Export the selected proxies to the file
        """
        ...
    def findProxyItem(self, name): ...
    def flags(self, index): ...
    def importAllFromFile(self, filePath, behavior, prependToName):
        """
        Import a complete render setup from that file
        """
        ...
    def importTemplate(*args, **kwargs): ...
    def isAcceptableTemplate(self, objList):
        """
        Find if the selected filename is a template for the render setup
        """
        ...
    def mimeData(self, indices):
        """
        This method builds the mimeData if the selection is correct
        """
        ...
    def mimeTypes(self): ...
    def paste(*args, **kwargs): ...
    def refreshModel(self): ...
    def renderSetupAdded(self): ...
    def renderSetupPreDelete(self): ...
    def resetModel(self): ...
    def supportedDropActions(self): ...
    def type(self): ...
    def typeIdx(self): ...
    @property
    def model(self):
        """
        Get the data model object for this proxy item.
        
        If the data model object does not exist, None is returned.
        """
        ...
    staticMetaObject : QMetaObject


class ModelProxyItem(Template, standardItem.StandardItem):
    """
    # Because of MAYA-60799, QStandardItem must appear last in the list of
    # base classes.
    """
    
    
    
    def __init__(self, model): ...
    def aboutToDelete(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def data(self, role): ...
    def dispose(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def equalsDragType(self, dragType): ...
    def findProxyItem(self, name): ...
    def getActionButton(self, column): ...
    def getActionButtonCount(self): ...
    def getWarning(self): ...
    def handleDragMoveEvent(self, event): ...
    def handleDropEvent(self, event, sceneView): ...
    def headingWidth(self, heading): ...
    def isActive(self): ...
    def isCopyable(self): ...
    def isDropAllowed(self, destinationModel): ...
    def isModelDirty(self):
        """
        # The next function (isModelDirty) is a workaround.
        # It should not be necessary but it is currently because we set tooltips in the treeview
        # and that triggers emitDataChanged which triggers the rebuild or repopulate of the property editor.
        # The proper fix will be to use columns in the treeview where each column has its own static tooltip
        # and the tooltips should no longer be dynamically set by the delegate (views/renderSetupDelegate.py)
        # depending on the lastHitAction
        """
        ...
    def isSelected(self): ...
    def modelChanged(*args, **kwargs): ...
    def onClick(self, view): ...
    def onDoubleClick(self, view): ...
    def paste(*args, **kwargs): ...
    def setData(self, value, role): ...
    def setSelected(self, value): ...
    @property
    def model(self):
        """
        Get the data model object for this proxy item.
        """
        ...


class BaseCollectionProxy(DataModelListObserver, LabelColor, ModelProxyItem):
    """
    # Because of MAYA-60799, PySide base classes must appear last in the list of
    # base classes.
    """
    
    
    
    def __init__(self, model): ...
    def aboutToDelete(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def attachChild(self, override, pos): ...
    def attachOverrideProxy(*args, **kwargs): ...
    def createListItemProxy(self, override): ...
    def createOverride(self, overrideTypeId): ...
    def data(self, role): ...
    def delete(self): ...
    def dispose(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def genericTypeIdx(self): ...
    def getDefaultColor(self): ...
    def getWarning(self): ...
    def importTemplate(*args, **kwargs): ...
    def isAcceptableTemplate(self, objList):
        """
        Only collections and overrides could be imported in a collection
        """
        ...
    def isSortingEnabled(self): ...
    def listItemAdded(self, listItem): ...
    def listItemRemoved(self, listItem): ...
    def setData(self, value, role): ...
    def setSortingEnabled(self, enabled): ...
    def type(self): ...


class SceneItemProxy(DataModelListObserver, ModelProxyItem):
    def __init__(self, model): ...
    def data(self, role): ...


class OverrideProxy(LabelColor, ModelProxyItem):
    """
    The class provides the Qt model counterpart for the Override
    """
    
    
    
    def __init__(self, model): ...
    def acceptsDrops(self, attribute): ...
    def data(self, role): ...
    def delete(self): ...
    def finalizeOverrideCreation(self, plugName): ...
    def genericTypeIdx(self): ...
    def getActionButton(self, column): ...
    def getActionButtonCount(self): ...
    def getDefaultColor(self): ...
    def getWarning(self): ...
    def isAcceptableTemplate(self, objList): ...
    def isLocalRender(self): ...
    def isUniqueOverride(self): ...
    def setData(self, value, role): ...
    def setLocalRender(self, value): ...
    def supportsAction(self, action, numIndexes): ...
    def type(self): ...
    def typeIdx(self): ...


class RenderLayerProxy(DataModelListObserver, LabelColor, ModelProxyItem):
    """
    # Because of MAYA-60799, PySide base classes must appear last in the list of
    # base classes.
    """
    
    
    
    def __init__(self, model): ...
    def aboutToDelete(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def attachChild(self, collection, pos): ...
    def createCollection(self, collectionName, nodeType): ...
    def createListItemProxy(self, collection): ...
    def data(self, role): ...
    def delete(self): ...
    def dispose(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def genericTypeIdx(self): ...
    def getActionButton(self, column): ...
    def getActionButtonCount(self): ...
    def getDefaultColor(self): ...
    def handleDragMoveEvent(self, event): ...
    def handleDropEvent(self, event, sceneView): ...
    def importTemplate(*args, **kwargs): ...
    def isAcceptableTemplate(self, objList):
        """
        Find if the selected filename is a template for a render layer
        """
        ...
    def isDropAllowed(self, destinationModel): ...
    def setData(self, value, role): ...
    def supportsAction(self, action, numIndexes): ...
    def type(self): ...
    def typeIdx(self): ...


class CamerasProxy(SceneItemProxy):
    def __init__(self, model): ...
    def data(self, role): ...
    def equalsDragType(self, dragType): ...
    def type(self): ...
    def typeIdx(self): ...


class LightsProxy(BaseCollectionProxy):
    def __init__(self, model): ...
    def aboutToDelete(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def data(self, role): ...
    def dispose(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def equalsDragType(self, dragType): ...
    def getActionButton(self, column): ...
    def getActionButtonCount(self): ...
    def isAcceptableTemplate(self, objList): ...
    def onDoubleClick(self, view): ...
    def supportsAction(self, action, numIndexes): ...
    def typeIdx(self): ...


class RenderSettingsCollectionProxy(BaseCollectionProxy):
    def __init__(self, model): ...
    def aboutToDelete(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def createCollection(self, collectionName, nodeType): ...
    def data(self, role): ...
    def dispose(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def equalsDragType(self, dragType): ...
    def getActionButton(self, column): ...
    def getActionButtonCount(self): ...
    def isAcceptableTemplate(self, objList):
        """
        Only render settings child collections and overrides can be imported into a render settings collection
        """
        ...
    def isActive(self): ...
    def onDoubleClick(self, view): ...
    def supportsAction(self, action, numIndexes): ...
    def typeIdx(self): ...


class RelOverrideProxy(OverrideProxy):
    def __init__(self, model): ...
    def createAttributeUI(self, attribute): ...


class CollectionProxy(BaseCollectionProxy):
    def __init__(self, model): ...
    def createCollection(self, collectionName, nodeType): ...
    def data(self, role): ...
    def getActionButton(self, column): ...
    def getActionButtonCount(self): ...
    def isAcceptableTemplate(self, objList):
        """
        Only collections and overrides could be imported in a collection
        """
        ...
    def supportsAction(self, action, numIndexes): ...
    def typeIdx(self): ...
    ABSOLUTE_OVERRIDE : unicode
    
    NO_OVERRIDE : unicode
    
    RELATIVE_OVERRIDE : unicode


class AOVsProxy(SceneItemProxy):
    def __init__(self, model): ...
    def data(self, role): ...
    def equalsDragType(self, dragType): ...
    def type(self): ...
    def typeIdx(self): ...


class AbsOverrideProxy(OverrideProxy):
    def __init__(self, model): ...
    def createAttributeUI(self, attribute): ...


class AOVCollectionProxy(BaseCollectionProxy):
    """
    # Can simplify this with a common base class
    """
    
    
    
    def __init__(self, model): ...
    def aboutToDelete(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def data(self, role): ...
    def dispose(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def equalsDragType(self, dragType): ...
    def getActionButton(self, column): ...
    def getActionButtonCount(self): ...
    def isAcceptableTemplate(self, objList): ...
    def isActive(self): ...
    def onDoubleClick(self, view): ...
    def supportsAction(self, action, numIndexes): ...
    def typeIdx(self): ...


class AOVChildCollectionProxy(BaseCollectionProxy):
    """
    # Can simplify this with a common base class
    """
    
    
    
    def __init__(self, model): ...
    def aboutToDelete(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def data(self, role): ...
    def dispose(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def getActionButton(self, column): ...
    def getActionButtonCount(self): ...
    def isAcceptableTemplate(self, objList): ...
    def supportsAction(self, action, numIndexes): ...
    def typeIdx(self): ...


class LightsChildCollectionProxy(BaseCollectionProxy):
    def __init__(self, model): ...
    def aboutToDelete(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def data(self, role): ...
    def dispose(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def getActionButton(self, column): ...
    def getActionButtonCount(self): ...
    def isAcceptableTemplate(self, objList): ...
    def supportsAction(self, action, numIndexes): ...
    def typeIdx(self): ...


class ConnectionOverrideProxy(OverrideProxy):
    def __init__(self, model): ...
    def acceptsDrops(self, attribute): ...
    def createAttributeUI(self, attribute): ...


class ShaderOverrideProxy(ConnectionOverrideProxy):
    def __init__(self, model): ...
    def acceptsDrops(self, attribute): ...
    def createAttributeUI(self, attribute): ...


class RelUniqueOverrideProxy(UniqueOverrideProxy, RelOverrideProxy):
    def __init__(self, model): ...


class MaterialOverrideProxy(ConnectionOverrideProxy):
    def __init__(self, model): ...
    def acceptsDrops(self, attribute): ...
    def createAttributeUI(self, attribute): ...


class ConnectionUniqueOverrideProxy(UniqueOverrideProxy, ConnectionOverrideProxy):
    def __init__(self, model): ...


class AbsUniqueOverrideProxy(UniqueOverrideProxy, AbsOverrideProxy):
    def __init__(self, model): ...


class RenderSettingsChildCollectionProxy(CollectionProxy):
    def __init__(self, model): ...
    def aboutToDelete(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def createCollection(self, collectionName, nodeType): ...
    def dispose(self):
        """
        Cleanup method to be called immediately before the object is deleted.
        """
        ...
    def equalsDragType(self, dragType): ...
    def getActionButton(self, column): ...
    def getActionButtonCount(self): ...
    def isAcceptableTemplate(self, objList):
        """
        Only render settings child collections and overrides can be imported into a render settings child collection
        """
        ...
    def supportsAction(self, action, numIndexes): ...
    def typeIdx(self): ...




def _createControlForAttribute(attr, attrLabel, connectable='True'):
    """
    Create a UI control for the given attribute, 
    matching its type and considering if it's connectable.
    """
    ...
def getProxy(dataModel):
    """
    # Returns the UI proxy associated with the given data model object. Note that
    # the proxy opaque data is a weakref, thus the () used to access the value.
    """
    ...


CREATE_RELATIVE_OVERRIDE_ACTION : unicode
DEFAULT_LAYER_COLOR : QColor
SET_LOCAL_RENDER_ACTION : unicode
FILTER_MENU : unicode
kConnectionType : unicode
CAMERAS_STR : unicode
CREATE_CONNECTION_OVERRIDE_ACTION : unicode
ALLFILTER_ACTION : unicode
RENDER_SETTINGS_CHILD_COLLECTION_TYPE_IDX : int
LIGHTS_STR : unicode
DEFAULT_COLLECTION_COLOR : QColor
COLLECTION_TYPE : int
CREATE_SHADER_OVERRIDE_ACTION : unicode
LIGHTS_CHILD_COLLECTION_TYPE : int
AOVS_TYPE : int
PARENT_TYPE_NAME : str
PROXY_OPAQUE_DATA : str
AOVS_STR : unicode
DISABLED_TEXT_COLOR : QColor
SET_ENABLED_ACTION : unicode
RENDER_OVERRIDE_TYPE_IDX : int
CREATE_MATERIAL_OVERRIDE_ACTION : unicode
RENDER_LAYER_TYPE : int
RENDER_SETTINGS_CHILD_COLLECTION_TYPE : int
CAMERASFILTER_ACTION : unicode
kCollectionWarningStr : unicode
AOVS_TYPE_IDX : int
TM_SHAPESFILTER_ACTION : unicode
CREATE_COLLECTION_ACTION : unicode
kRelativeType : unicode
LIGHTS_TYPE_IDX : int
RENDER_SETTINGS_TYPE : int
DEFAULT_OVERRIDE_COLOR : QColor
TM_SHAPES_SHADERSFILTER_ACTION : unicode
colors : dict
CAMERAS_TYPE : int
kMaterialType : unicode
CAMERAS_TYPE_IDX : int
AOVS_CHILD_COLLECTION_TYPE_IDX : int
LIGHTSFILTER_ACTION : unicode
EXPAND_COLLAPSE_ACTION : unicode
RENDER_SETUP_MIME_TYPE : str
kOverrideWarningStr : unicode
SHADERSFILTER_ACTION : unicode
DEFAULT_TEXT_COLOR : QColor
SET_ISOLATE_SELECTED_ACTION : unicode
CREATE_RENDER_SETTINGS_CHILD_COLLECTION_ACTION : unicode
RENAME_ACTION : unicode
COLLECTION_TYPE_IDX : int
RENDER_SETTINGS_STR : unicode
kRenderLayerWarningStr : unicode
kNoOverride : unicode
kDragAndDrop : unicode
CUSTOMFILTER_ACTION : unicode
kAbsoluteType : unicode
FULLY_EXPAND_COLLAPSE_ACTION : unicode
RENDER_LAYER_TYPE_IDX : int
NEWFILTER_ACTION : unicode
LIGHTS_CHILD_COLLECTION_TYPE_IDX : int
TRANSFORMSFILTER_ACTION : unicode
SET_RENDERABLE_ACTION : unicode
kRelative : unicode
SET_VISIBILITY_ACTION : unicode
LIGHTS_TYPE : int
kSelectionTypeError : unicode
CREATE_ABSOLUTE_OVERRIDE_ACTION : unicode
SHAPESFILTER_ACTION : unicode
RENDER_SETTINGS_TYPE_IDX : int
RENDER_SETUP_TYPE : int
MAX_TYPE_IDX : int
SETSFILTER_ACTION : unicode
kShaderType : unicode
DELETE_ACTION : unicode
kAbsolute : unicode
RENDER_OVERRIDE_TYPE : int
AOVS_CHILD_COLLECTION_TYPE : int
RENDER_SETUP_TYPE_IDX : int
kDragAndDropFailed : unicode

