from typing import Any, Container, Dict, Generic, Iterable, Iterator, List, Optional, Set, Tuple, TypeVar, Union
import pymel.versions as versions
import pymel.util as util
import re
import platform
import xml.etree.cElementTree as ET
from . import plogging
import os


from abc import ABCMeta
from abc import abstractmethod
from pymel.util.external.BeautifulSoup import NavigableString
from HTMLParser import HTMLParser
from pymel.util.external.BeautifulSoup import BeautifulSoup
from pymel.mayautils import getMayaLocation


if False:
    from typing import Dict, List, Tuple, Union, Optional

class NodeHierarchyDocParser(HTMLParser):
    def __init__(self, version='None'): ...
    def handle_data(self, data): ...
    def handle_starttag(self, tag, attrs): ...
    def parse(self): ...


class ApiDocParser(object):
    def __init__(self, apiModule, version='None', verbose='False', enumClass='"<type \'tuple\'>"', docLocation='None', strict='False'): ...
    def __repr__(self) -> str: ...
    def formatMsg(self, *args): ...
    def fullMethodName(self): ...
    def getClassFilename(self): ...
    def getClassPath(self): ...
    def getMethodNameAndOutput(self): ...
    def getOperatorName(self, methodName): ...
    def getPymelMethodNames(self): ...
    def handleEnumDefaults(self, default, type): ...
    def handleEnums(self, type): ...
    def hasNoPython(self): ...
    def isBadEnum(self, type): ...
    def isGetMethod(self): ...
    def isSetMethod(self): ...
    def isStaticMethod(self): ...
    def parse(self, apiClassName): ...
    def parseArgTypes(self): ...
    def parseBody(self): ...
    def parseEnum(self, enumData): ...
    def parseMethod(self, rawMethod): ...
    def parseMethodArgs(self, returnType, names, types, typeQualifiers): ...
    def parseType(self, tokens): ...
    def parseValue(self, rawValue, valueType): ...
    def setClass(self, apiClassName): ...
    def xprint(self, *args): ...
    @staticmethod
    def __new__(cls, apiModule, version='None', *args, **kwargs): ...
    DEPRECATED_MSG : list
    
    MISSING_TYPES : list
    
    NOT_TYPES : list
    
    NO_PYTHON_MSG : list
    
    OTHER_TYPES : list
    
    PYMEL_ENUM_DEFAULTS : dict
    
    __abstractmethods__ : frozenset
    
    __dict__ : dictproxy
    
    
    
    __weakref__ : getset_descriptor


class MLStripper(HTMLParser):
    """
    # Thanks to Eloff for this snippet: https://stackoverflow.com/a/925630/920545
    """
    
    
    
    def __init__(self): ...
    def get_data(self): ...
    def handle_data(self, d): ...


class CommandDocParser(HTMLParser):
    def __init__(self, command): ...
    def __repr__(self) -> str: ...
    def addFlagData(self, data): ...
    def endFlag(self): ...
    def handle_data(self, data): ...
    def handle_endtag(self, tag): ...
    def handle_entityref(self, name): ...
    def handle_starttag(self, tag, attrs): ...
    def startFlag(self, data): ...


class CommandModuleDocParser(HTMLParser):
    def __init__(self, category, version='None'): ...
    def handle_starttag(self, tag, attrs): ...
    def parse(self): ...


class XmlApiDocParser(ApiDocParser):
    def fullMethodName(self): ...
    def getClassPath(self): ...
    def getMethodNameAndOutput(self): ...
    def hasNoPython(self): ...
    def isDeprecated(self): ...
    def isStaticMethod(self): ...
    def parseArgTypes(self): ...
    def parseBody(self): ...
    def parseMethodArgs(self, returnType, names, types, typeQualifiers): ...
    def setClass(self, apiClassName): ...
    @classmethod
    def iterBackslashTags(cls, text, subTags="('li',)"):
        """
        Iterator that parses text with tags like: "\tag Some text for tag"
        
        Sometimes detail text does not parse parameters properly, and we end up with text like this,
        from 2019 MFnMesh.addPolygon 2nd overload (with 6 args):
        
        If we are adding to an existing polygonal mesh then parentOrOwner is
        ignored and the geometry is returned.
        
        \param[in] vertexArray Array of ordered vertices that make up the polygon.
        \param[in] loopCounts Array of vertex loop counts.
        \param[out] faceIndex Index of the newly added polygon.
        \param[in] mergeVertices If true then if a vertex falls within
                                                            pointTolerance of an existing vertex then the
                                                            existing vertex is reused.
        \param[in] pointTolerance Specifies how close verticies have to be to
                                                            before they are &lt;i&gt;merged&lt;/i&gt;.  This merging is
                                                            only done if &lt;i&gt;mergeVerticies&lt;/i&gt; is true.
        \param[in] parentOrOwner The DAG parent or kMeshData the new
                                                            surface will belong to.
        \param[out] ReturnStatus Status code.
        
        \return
        The transform if one is created, otherwise the geometry.
        
        This code will iterate through, finding lines that start with a "backslash tag", and issuing tuples like this:
        
        ("param[in]", "vertexArray Array of ordered vertices that make up the polygon.\n")
        ("param[in]", "loopCounts Array of vertex loop counts.\n")
        
        The text before we find the first tag will be ignored.
        """
        ...
    @classmethod
    def parseBackslashTags(cls, text): ...
    __abstractmethods__ : frozenset


class HtmlApiDocParser(ApiDocParser):
    def getClassPath(self): ...
    def getDoxygenVersion(self, soup): ...
    def getMethodNameAndOutput(self): ...
    def hasNoPython(self): ...
    def isStaticMethod(self): ...
    def parseArgTypes(self): ...
    def parseBody(self): ...
    def parseMethodArgs(self, returnType, names, types, typeQualifiers): ...
    def setClass(self, apiClassName): ...
    DOXYGEN_VER_RE : re.SRE_Pattern
    
    TYPEDEF_RE : re.SRE_Pattern
    
    __abstractmethods__ : frozenset




def mayaDocsLocation(version='None'): ...
def getFirstText(element, ignore="('ref', 'bold', 'emphasis')"):
    """
    Finds a non-empty text element, then stops once it hits not first non-filtered sub-element
    
    >>> getFirstText(ET.fromstring('<top>Some text. <sub>Blah</sub> tail.</top>'))
    'Some text.'
    >>> getFirstText(ET.fromstring('<top><sub>Blah blah</sub> More stuff</top>'))
    'Blah blah'
    >>> getFirstText(ET.fromstring('<top> <sub>Blah blah <ref>someRef</ref> More stuff</sub> The end</top>'))
    'Blah blah someRef More stuff'
    """
    ...
def _iskeyword(*args, **kwargs):
    """
    x.__contains__(y) <==> y in x.
    """
    ...
def standardizeWhitespace(text): ...
def xmlText(element, strip='True', allowNone='True'):
    """
    Given an xml Element object, returns it's full text (with children)
    
    If predicate is given, and it returns False for this element or any child,
    then text generation will be terminated at that point.
    """
    ...
def strip_tags(html): ...
def mayaIsRunning():
    """
    Returns True if maya.cmds have  False otherwise.
    
    Early in interactive startup it is possible for commands to exist but for Maya to not yet be initialized.
    
    Returns
    -------
    bool
    """
    ...
def printTree(tree, depth='0'): ...
def iterXmlTextAndElem(element):
    """
    Like Element.itertext, except returns a tuple of (text, element, isTail)
    """
    ...


_logger : plogging.Logger
FLAGMODES : tuple

